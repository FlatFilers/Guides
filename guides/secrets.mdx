---
title: "Share secrets"
description: "Learn how to securely use credentials in listeners."
icon: "user-secret"
---

With Secrets you can securely share credentials with listener implementations
without developers explicitly knowing the secret values upfront. Secret values
are set in the user interface, but retrieved via the SDK or
[API](https://reference.flatfile.com/docs/api/385183f8a52af-list-all-secrets-for-an-environment-or-environment-space).

## Overview

### Creating Secrets

Secrets in Flatfile, defined as Name/Value pairs, are securely stored and associated
with an Environment or Space. Spaces will inherit the Secrets from their respective
Environment, and you can additionally override the Environment Secret to a specific
value for each specific space. To define Secrets shared with every Space in an
Envrionment, navigate to the "Developer Settings" screen for that environment.
To override an environment value, navigate to the specific Space and select "Secrets"
in the left navigation.

A note on security: while all of Flatfile data employs encryption during transit
at rest in our datastore, Secrets adds an additional layer of protection on demand
encrypting/decrypting the values using an unique set of keys. As such a potential
intruder would need not only access to the plaintext datastore, but also these
extra keys to decrypt and compromise these sensitive values.

### Consuming Secrets

While Secrets are defined in administrative interfaces for Environments, and Spaces,
respectively, they are designed to be consumed by Listeners. While it might be trivia
to pass in secret values through the environment variables with a self-hosted
Listener, with a Flatfile hosted Agent based Listener one must use the Secrets
features. See Usage below for some example consumer patterns.

## Usage Examples

### Sensitive Credentials

The principal utility of Secrets lies in securely storing sensitive credentials/tokens
within an Environment/Space for connecting Listeners to third-party APIs. For
instance, you might store a secret named `SLACK_TOKEN` with a value of
`xoxb-e5b7206ccac446048a8a52b703dbb4b9`, allowing you to communicate with a
Slack bot each time a custom action is triggered.

#### Example Listener

In this example, we use an `event.secrets` call to pull a sensitive Slack token
for use within a listener context. We then can use the credential to post a
message to Slack.

```jsx
listener.on("**", async (event) => {
  const tok = await event.secrets("SLACK_TOKEN");
  slack = new Slack(tok);
  slack.api(
    "chat.postMessage",
    {
      text: "Flatfile event received!",
      channel: "#integration-flatfile",
    },
    function (err, response) {
      console.log(response || err);
    }
  );
});
```

#### Example using optional EnvironmentId or SpaceId

the `options` parameter for the secrets fetch function allows optionally choosing
a different Environment or Space than the event occurred within. This is useful

```jsx
listener.on("**", async (event) => {
  // Hardcode specific environment and space for this listener's case
  const credential = await event.secrets("MY_CREDENTIAL", {
    environmentId: "us_env_123",
    spaceId: "us_spa_123",
  });
});
```

## Metadata

While it might seem creative to use the Secrets feature to hold non-sensitive
metadata. We encourage you to learn more about [utilizing metadata](./metadata)
about your Spaces, Records, or Fields.
